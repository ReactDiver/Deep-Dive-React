- 리액트에서 제공하는 API 중 `useMemo`, `useCallback` 훅과 고차 컴포넌트인 `memo`는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해서 제공된다.
- 메모이제이션 최적화에 대해서는 갑론을박이 이어지고 있다.
<br>

## 주장1 : 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자
- 메모이제이션은 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업, 그리고 이전에 결과물을 저장해 두었다가 다시 꺼내와야 한다는 두 가지 비용이 든다.
- 따라서, 어디까지나 비용이 드는 작업이므로 최적화에 대해서는 항상 신중해야 한다는 주장이다.
- 일단 애플리케이션을 어느 정도 만든 이후에 개발자 도구나 `useEffect`를 사용해 실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에서만 최적화하는 것이 옳다.
<br>

## 주장2 : 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자
- 앞선 주장이 가장 이상적이지만, 실무 개발자들은 최적화나 성능 향상에 쏟을 시간이 많지 않다.
- 섣부른 최적화인지 여부와는 관계없이, 만약 해당 컴포넌트가 렌더링이 자주 일어나며 그 렌더링 사이에 비싼 연산이 포함돼 있고, 심지어 그 컴포넌트가 자식 컴포넌트 또한 많이 가지고 있다면 memo나 다른 메모이제이션 방법을 사용하는 것이 이점이 있을 때가 있다.

  ### memo를 하지 않았을 때 발생할 수 있는 문제
  - 렌더링을 함으로써 발생하는 비용
  - 컴포넌트 내부의 복잡한 로직의 재실행
  - 위 두 가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
  - 리액트가 구 트리와 신규 트리를 비교

- 따라서, 메모이제이션은 하지 않는 것보다 메미오제이션했을 때 더 많은 이점을 누릴 수 있다.
<br>

## 정리
> 저자의 사견을 기술하였다.
- 아직 리액트를 배우고 있거나 혹은 리액트를 깊이 이해하고 싶고, 이를 위해 시간을 투자할 여유가 있다면 주장1처럼 섣부른 메모이제이션을 지양하는 자세를 견지하면서 실제 어느 지점에서 성능상 이점을 누릴 수 있는지 살펴보는 식으로 메모이제이션을 적용하는 것을 권장한다.
- 만약 현업에서 리액트를 사용하고 있거나 실제로 다룰 예정이지만 성능에 대해 깊게 연구해 볼 시간적 여유가 없는 상황이라면 일단 의심스러운 곳에는 먼저 다 적용해 볼 것을 권장한다.
- 다른 컴포넌트의 `props`로 넘아갔을 때 참조 투명성을 유지하기 위해서는 `useCallback`을 사용하는 것이 좋다.
- `useMemo` 또한 `props`로 넘어가거나 이를 활용할 여지가 있다면 사용하는 것이 좋다.
