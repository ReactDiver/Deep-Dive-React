# 3장 리액트 훅 깊게 살펴보기

## 3-1. 리액트 훅 (hook)

#### useState
- 함수 컴포넌트 내부에서 상태를 정의하고 이 상태를 관리할 수 있게 해주는 훅

```js
//기본 사용법
const [state, setState] = useState(initialState) //설정값 없으면 undefined

/* useState 반환값은 배열,
첫번째 원소로 state 값 자체를 사용할 수 있고 두번째 원소로 state 값을 변경할 수 있다

리액트 렌더링은 렌더링이 발생할 때마다 함수가 새로 실행되는데
useState 결과값은 어떻게 함수가 실행돼도 값을 유지할까? -> 클로저

클로저는 setState 가 함수 실행 종료 후에도 state 를 계속 참조할 수 있음을 의미한다 */
```

#### 게으른 초기화 (lazy initialization)
- useState의 초기값이 복잡하거나 무거운 연산을 포함할때 사용 <br />
  무거운 연산 : localStorage, sessionStorage 접근 , map, filter, find 같은 배열 접근이나 초기값 계산을 위한 함수 호출
- 게으른 초기화 함수는 state가 처음 만들어질때만 사용, 리렌더링 발생하면 함수 실행은 무시된다
```js
//게으른 초기화 일반적인 useState 와 다르게 함수를 실행해 값을 반환한다
const [count, setCount] = useState(() =>
  Number.parseInt(window.localStorage.getItem(cacheKey)),
)
/* window.localStorage.getItem(cacheKey) 같이 한 번 실행하는데 비용이 드는 값은
함수 형태로 인수에 넘겨줘야 리렌더링시 계속 값에 접근하지않아 낭비가 생기지 않는다  */
```

#### useEffect
- 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 매커니즘
```js
//기본 사용법
useEffect(() => {
....
}, [props, state]) 

/* 첫번째 인수는 실행 부수 효과가 포함된 함수, 두번째 인수는 의존성 배열
의존성 배열이 변경될 때마다 useEffect 첫번째 인수인 콜백을 실행한다
useEffect 가 어떻게 의존성 배열이 변경된걸 알까? */

function Component(){
  const counter = 1

  function handleClick() {
    setCounter((prev) => prev + 1)
  }

  useEffect(() => {
    console.log(counter)
  })
}
  return (
    <>
      <h1>{counter}</h1>
      <button onClick={handleClick}+</button>
  )

/* 함수 컴포넌트는 렌더링시 고유의 state 와 props 를 가지고 있다
useEffect 는 렌더링할 때마다 state 와 props 을 보면서 이 값들이 전과 다른게 하나라도 있다면 부수 효과를 실행하는 함수  */
```


