> 리액트에서는 재사용할 수 있는 로직을 관리할 수 있는 두 가지 방법이 있는데, <mark>사용자 정의 훅</mark>과 <mark>고차 컴포넌트</mark>다.
<br>

# 1. 사용자 정의 훅(custom hook)
- 서로 다른 컴포넌트 내부에서 같은 로직을 공유하고자 할 때 주로 사용되는 기법이다.
- 리액트에서만 사용할 수 있다.
- 이름이 반드시 `use`로 시작하는 함수를 만들어야 한다. 예) useFetch 등
<br>

# 2. 고차 컴포넌트(HOC, higher order component)
- 컴포넌트 자체의 로직을 재사용하기 위한 기법이다.
- 고차 함수의 일종으로, 자바스크립트의 일급 객체, 함수의 특징을 이용하므로 굳이 리액트가 아니더라도 자바스크립트 환경에서 널리 쓰일 수 있다.
- 가장 유명한 고차 컴포넌트는 `React.memo`다.
<br>

## React.memo란?
- `props`의 변화가 없음에도 컴포넌트의 렌더링을 방지하기 위해 만들어진 리액트의 고차 컴포넌트이다.
- 렌더링하기에 앞서 `props`를 비교해 이전과 `props`가 같다면 <mark>렌더링 자체를 생략하고 이전에 기억해 둔 컴포넌트를 반환한다.</mark>
<br>

```typescript
const ChildComponent = memo(({ value }: { value: string }) => {
  useEffect(() => {
    console.log('렌더링')
  })

  return <>안녕하세요! {value}</>
})

function ParentComponent() {
  const [state, setState] = useState(1)

  function handleChange(e: ChangeEvent<HYMLInputElement>) {
    setState(Number(e.target.value))
  }

  retrun (
    <>
      <input type="number" value={state} onChange={handleChange} />
      <ChildComponent value="hello" />
    </>
  )
}

// ParentComponent에서 아무리 state가 변경돼도 ChildComponent는 다시 렌더링되지 않는다.
```
<br>

> useMemo를 사용해도 동일하게 메모이제이션할 수 있지 않을까?
> - useMemo를 사용할 경우 값을 반환받기 때문에 JSX 함수 방식이 아닌 {}을 사용한 할당식을 사용해야 한다.
> - 혼선을 빚을 수 있으므로 목적과 용도가 뚜렷한 `memo`를 사용하는 것이 좋다.
<br>

## 고차 함수 만들어보기
- 고차 함수의 사전정 정의: '함수를 인수로 받거나 결과로 반환하는 함수'
- 대표적인 고차 함수로는 리액트에서 배열을 렌더링할 때 자주 사용하는 `Array.prototype.map`이 있다.
